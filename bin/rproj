#!/usr/bin/env bash

set -euo pipefail

# rproj - Unified Remote Project Tool
#
# Subcommands:
#   list   List remote projects (optionally as JSON for Alfred)
#   tmux   Open tmux session for a remote project
#   code   Open VS Code for a remote project
#   help   Show this help
#
# Run with no arguments for interactive mode.

SCRIPT_NAME="$(basename "$0")"
SCRIPT_PATH="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)/$(basename "${BASH_SOURCE[0]}")"

# Config file location
CONFIG_FILE="${XDG_CONFIG_HOME:-$HOME/.config}/rproj/config"

# Defaults (overridden by config file, then by command-line args)
RPROJ_HOST="workmbp"
RPROJ_DIR="/Users/thomas.lockney/src/metron"

# Load config if it exists
if [[ -f "$CONFIG_FILE" ]]; then
    # shellcheck source=/dev/null
    source "$CONFIG_FILE"
fi

# Colors (disabled in JSON mode)
RED='\033[0;31m'
GREEN='\033[0;32m'
BLUE='\033[0;34m'
NC='\033[0m'

# State
JSON_MODE=false
QUERY=""
PROJECT_PATH=""

# Logging (respects JSON mode)
info() {
    [[ "$JSON_MODE" == "true" ]] && return
    echo -e "${BLUE}$*${NC}"
}

success() {
    [[ "$JSON_MODE" == "true" ]] && return
    echo -e "${GREEN}$*${NC}"
}

error() {
    if [[ "$JSON_MODE" == "true" ]]; then
        cat << EOF
{"items": [{
    "title": "Error",
    "subtitle": "$*",
    "valid": false,
    "icon": {"path": "error.png"}
}]}
EOF
        exit 0
    else
        echo -e "${RED}Error: $*${NC}" >&2
        exit 1
    fi
}

# Parent directory display label
parent_label() {
    echo "ðŸ“‚ $(basename "$1")"
}

# Resolve selected project to full path
resolve_project_path() {
    local selected="$1"
    local dir="$2"
    local plabel
    plabel=$(parent_label "$dir")

    if [[ "$selected" == "$plabel" ]]; then
        echo "$dir"
    else
        echo "$dir/$selected"
    fi
}

# Help message
show_help() {
    cat << EOF
Usage: $SCRIPT_NAME [command] [options] [project]

Commands:
    list  (l)   List remote projects
    tmux  (t)   Open tmux session for a project
    code  (c)   Open VS Code for a project
    open  (o)   Open from Alfred (host|path format)
    help        Show this help

    If no command is given, interactively select a project and action.

Options:
    -h, --host HOST   Remote host (default: $RPROJ_HOST)
    -d DIR            Remote directory (default: $RPROJ_DIR)
    -p NAME           Project name (skip interactive selection)
    --json            Output as Alfred-compatible JSON (list command only)
    -q QUERY          Filter projects by query (list command with --json)
    --help            Show this help

Examples:
    $SCRIPT_NAME                         # Interactive: pick project & action
    $SCRIPT_NAME l                       # List all projects (short form)
    $SCRIPT_NAME list --json             # JSON output for Alfred
    $SCRIPT_NAME t                       # Interactive tmux selection
    $SCRIPT_NAME tmux myproject          # Direct to 'myproject' tmux
    $SCRIPT_NAME c -h otherhost          # VS Code on different host
    $SCRIPT_NAME code -p myproject       # Direct to 'myproject' in VS Code

Config file: $CONFIG_FILE
EOF
    exit 0
}

# Test SSH connection and verify directory exists
test_connection() {
    local host="$1"
    local dir="$2"
    local timeout="${3:-5}"

    info "Connecting to $host..."
    if ! ssh -o BatchMode=yes -o ConnectTimeout="$timeout" "$host" "test -d '$dir'" 2>/dev/null; then
        error "Cannot connect to $host or directory $dir doesn't exist.\n  Check your SSH config or try: ssh -v $host"
    fi
}

# Discover projects on remote host
discover_projects() {
    local host="$1"
    local dir="$2"

    ssh "$host" "find '$dir' -maxdepth 1 -mindepth 1 -type d -not -name '.*' | sort" 2>/dev/null
}

# Preview a project (called internally by fzf --preview)
cmd_preview() {
    local host="$1"
    local dir="$2"
    local item="$3"
    local path

    if [[ "$item" == ðŸ“‚* ]]; then
        path="$dir"
    else
        path="$dir/$item"
    fi

    ssh -o ConnectTimeout=2 "$host" "
        echo '$path'
        echo
        if git -C '$path' rev-parse --git-dir >/dev/null 2>&1; then
            echo 'Branch:'
            git -C '$path' branch --show-current 2>/dev/null
            echo
            echo 'Recent commits:'
            git -C '$path' log --oneline -5 2>/dev/null
            echo
        fi
        echo 'Contents:'
        ls -1 '$path' 2>/dev/null | head -20
    " 2>/dev/null
}

# Interactive project selection with fzf
select_project() {
    local projects="$1"
    local dir="$2"
    local host="$3"

    local plabel
    plabel=$(parent_label "$dir")

    echo "$projects" | sed "s|^${dir}$|${plabel}|; s|${dir}/||" | fzf \
        --height=60% \
        --layout=reverse \
        --border \
        --cycle \
        --prompt="Select project: " \
        --header="Select a project to open" \
        --preview "'$SCRIPT_PATH' _preview '$host' '$dir' {}"
}

# Verify a specific project exists
verify_project() {
    local host="$1"
    local project_path="$2"

    if ! ssh -o BatchMode=yes "$host" "test -d '$project_path'" 2>/dev/null; then
        error "Project not found at $project_path on $host"
    fi
}

# Get project selection - interactive or by name
# Sets global PROJECT_PATH
get_project_selection() {
    local host="$1"
    local dir="$2"
    local project_name="$3"

    if [[ -n "$project_name" ]]; then
        local plabel
        plabel=$(parent_label "$dir")
        if [[ "$project_name" == "$plabel" ]]; then
            PROJECT_PATH="$dir"
        else
            PROJECT_PATH="$dir/$project_name"
            verify_project "$host" "$PROJECT_PATH"
        fi
        info "Using project: $project_name"
    else
        info "Finding projects in $dir..."
        local projects
        projects=$(discover_projects "$host" "$dir")

        # Prepend parent directory as an option
        if [[ -n "$projects" ]]; then
            projects="$dir"$'\n'"$projects"
        else
            projects="$dir"
        fi

        local selected
        selected=$(select_project "$projects" "$dir" "$host")
        [[ -z "$selected" ]] && { echo "Cancelled."; exit 0; }

        PROJECT_PATH=$(resolve_project_path "$selected" "$dir")
    fi
}

# Output projects as Alfred JSON
output_alfred_json() {
    local projects="$1"
    local host="$2"
    local query="$3"

    if [[ -z "$projects" ]]; then
        cat << EOF
{"items": [{
    "title": "No Projects Found",
    "subtitle": "No projects found in $RPROJ_DIR on $host",
    "valid": false,
    "icon": {"path": "error.png"}
}]}
EOF
        return
    fi

    echo '{"items": ['

    local first=true
    while IFS= read -r project; do
        local project_name display_name
        project_name=$(basename "$project")
        if [[ "$project" == "$RPROJ_DIR" ]]; then
            display_name=$(parent_label "$RPROJ_DIR")
        else
            display_name="$project_name"
        fi

        # Filter by query if provided (case-insensitive)
        if [[ -n "$query" ]] && [[ ! "${project_name,,}" =~ ${query,,} ]]; then
            continue
        fi

        if [[ "$first" != "true" ]]; then
            echo ","
        fi
        first=false

        cat << EOF
{
    "uid": "$project_name",
    "title": "$display_name",
    "subtitle": "Open in VS Code: $project",
    "arg": "$host|$project",
    "autocomplete": "$project_name",
    "icon": {"path": "vscode.png"}
}
EOF
    done <<< "$projects"

    echo ']}'
}

# Parse common options for a subcommand
# Sets: RPROJ_HOST, RPROJ_DIR, PROJECT_NAME
parse_options() {
    PROJECT_NAME=""

    while [[ $# -gt 0 ]]; do
        case $1 in
            --help)
                show_help
                ;;
            -h|--host)
                if [[ $# -lt 2 ]]; then
                    error "Option $1 requires a host argument"
                fi
                RPROJ_HOST="$2"
                shift 2
                ;;
            -d)
                if [[ $# -lt 2 ]]; then
                    error "Option -d requires a directory argument"
                fi
                RPROJ_DIR="$2"
                shift 2
                ;;
            -p)
                if [[ $# -lt 2 ]]; then
                    error "Option -p requires a project name"
                fi
                PROJECT_NAME="$2"
                shift 2
                ;;
            --json)
                JSON_MODE=true
                shift
                ;;
            -q)
                if [[ $# -lt 2 ]]; then
                    error "Option -q requires a query string"
                fi
                QUERY="$2"
                shift 2
                ;;
            -*)
                error "Unknown option: $1"
                ;;
            *)
                # Positional argument is project name
                PROJECT_NAME="$1"
                shift
                ;;
        esac
    done
}

# Command: list
cmd_list() {
    parse_options "$@"

    # Use shorter timeout for JSON mode (Alfred)
    local timeout=5
    [[ "$JSON_MODE" == "true" ]] && timeout=2

    test_connection "$RPROJ_HOST" "$RPROJ_DIR" "$timeout"

    info "Finding projects in $RPROJ_DIR..."
    local projects
    projects=$(discover_projects "$RPROJ_HOST" "$RPROJ_DIR")

    # Prepend parent directory as an option
    if [[ -n "$projects" ]]; then
        projects="$RPROJ_DIR"$'\n'"$projects"
    else
        projects="$RPROJ_DIR"
    fi

    if [[ "$JSON_MODE" == "true" ]]; then
        output_alfred_json "$projects" "$RPROJ_HOST" "$QUERY"
    else
        local plabel
        plabel=$(parent_label "$RPROJ_DIR")
        echo "$projects" | sed "s|^${RPROJ_DIR}$|${plabel}|; s|${RPROJ_DIR}/||"
    fi
}

# Command: tmux
cmd_tmux() {
    parse_options "$@"
    test_connection "$RPROJ_HOST" "$RPROJ_DIR"
    get_project_selection "$RPROJ_HOST" "$RPROJ_DIR" "$PROJECT_NAME"

    local session_name
    session_name=$(basename "$PROJECT_PATH")
    success "Opening tmux session '$session_name' at $PROJECT_PATH..."

    # Connect and run tc to create/attach tmux session
    ssh -A -t "$RPROJ_HOST" "cd '$PROJECT_PATH' && ~/bin/tc"
}

# Command: code
cmd_code() {
    parse_options "$@"
    test_connection "$RPROJ_HOST" "$RPROJ_DIR"
    get_project_selection "$RPROJ_HOST" "$RPROJ_DIR" "$PROJECT_NAME"

    success "Opening $PROJECT_PATH in VS Code..."
    code --remote "ssh-remote+$RPROJ_HOST" "$PROJECT_PATH"
}

# Command: default (interactive project + action selection)
cmd_default() {
    parse_options "$@"
    test_connection "$RPROJ_HOST" "$RPROJ_DIR"
    get_project_selection "$RPROJ_HOST" "$RPROJ_DIR" "$PROJECT_NAME"

    local project_display
    project_display=$(basename "$PROJECT_PATH")

    local action
    action=$(printf "tmux\ncode" | fzf \
        --height=30% \
        --layout=reverse \
        --border \
        --no-preview \
        --prompt="Action: " \
        --header="Open '$project_display' with:")

    [[ -z "$action" ]] && { echo "Cancelled."; exit 0; }

    case "$action" in
        tmux)
            local session_name
            session_name=$(basename "$PROJECT_PATH")
            success "Opening tmux session '$session_name' at $PROJECT_PATH..."
            ssh -A -t "$RPROJ_HOST" "cd '$PROJECT_PATH' && ~/bin/tc"
            ;;
        code)
            success "Opening $PROJECT_PATH in VS Code..."
            code --remote "ssh-remote+$RPROJ_HOST" "$PROJECT_PATH"
            ;;
    esac
}

# Command: open (for Alfred - opens with host|path format)
cmd_open() {
    if [[ $# -lt 1 ]]; then
        error "Usage: $SCRIPT_NAME open 'host|path'"
    fi

    local arg="$1"
    local host path
    IFS='|' read -r host path <<< "$arg"

    if [[ -z "$host" ]] || [[ -z "$path" ]]; then
        error "Invalid argument format. Expected 'host|path'"
    fi

    code --remote "ssh-remote+$host" "$path"
}

# Main
main() {
    if [[ $# -lt 1 ]]; then
        cmd_default
        return
    fi

    local command="$1"
    shift

    case "$command" in
        l|list)
            cmd_list "$@"
            ;;
        t|tmux)
            cmd_tmux "$@"
            ;;
        c|code)
            cmd_code "$@"
            ;;
        o|open)
            cmd_open "$@"
            ;;
        _preview)
            cmd_preview "$@"
            ;;
        help|--help)
            show_help
            ;;
        -*)
            # Options without a subcommand -> interactive mode
            cmd_default "$command" "$@"
            ;;
        *)
            error "Unknown command: $command. Use '$SCRIPT_NAME help' for usage."
            ;;
    esac
}

main "$@"
