#!/bin/bash

# Git Repository Status Checker
# Usage: ./git_status_checker.sh [directory] [options]
# Options:
#   -p, --check-push    Also check for unpushed commits
#   -v, --verbose       Show detailed output
#   -h, --help          Show this help message

set -e

# Default values
TARGET_DIR="."
CHECK_PUSH=false
VERBOSE=false

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Function to print usage
show_help() {
    echo "Usage: $0 [directory] [options]"
    echo ""
    echo "Options:"
    echo "  -p, --check-push    Also check for unpushed commits"
    echo "  -v, --verbose       Show detailed output"
    echo "  -h, --help          Show this help message"
    echo ""
    echo "Examples:"
    echo "  $0                           # Check current directory"
    echo "  $0 /path/to/projects        # Check specific directory"
    echo "  $0 ~/projects -p            # Check with push status"
    echo "  $0 ~/projects -p -v         # Check with push status and verbose output"
}

# Parse command line arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        -p|--check-push)
            CHECK_PUSH=true
            shift
            ;;
        -v|--verbose)
            VERBOSE=true
            shift
            ;;
        -h|--help)
            show_help
            exit 0
            ;;
        -*)
            echo "Unknown option $1"
            show_help
            exit 1
            ;;
        *)
            TARGET_DIR="$1"
            shift
            ;;
    esac
done

# Check if target directory exists
if [[ ! -d "$TARGET_DIR" ]]; then
    echo -e "${RED}Error: Directory '$TARGET_DIR' does not exist${NC}"
    exit 1
fi

# Function to check if directory is a git repository
is_git_repo() {
    local dir="$1"
    [[ -d "$dir/.git" ]] || git -C "$dir" rev-parse --git-dir >/dev/null 2>&1
}

# Function to check for uncommitted changes
check_uncommitted_changes() {
    local dir="$1"
    local repo_name
    repo_name=$(basename "$dir")

    cd "$dir"

    # Check for uncommitted changes
    if ! git diff-index --quiet HEAD --; then
        echo -e "${YELLOW}  ‚ö†Ô∏è  Uncommitted changes found${NC}"
        if [[ "$VERBOSE" == true ]]; then
            echo "      Modified files:"
            git diff-index --name-only HEAD -- | sed 's/^/        /'
        fi
        return 1
    fi

    # Check for untracked files
    if [[ -n $(git ls-files --others --exclude-standard) ]]; then
        echo -e "${YELLOW}  ‚ö†Ô∏è  Untracked files found${NC}"
        if [[ "$VERBOSE" == true ]]; then
            echo "      Untracked files:"
            git ls-files --others --exclude-standard | sed 's/^/        /'
        fi
        return 1
    fi

    # Check for staged changes
    if ! git diff-index --quiet --cached HEAD --; then
        echo -e "${YELLOW}  ‚ö†Ô∏è  Staged changes found${NC}"
        if [[ "$VERBOSE" == true ]]; then
            echo "      Staged files:"
            git diff-index --name-only --cached HEAD -- | sed 's/^/        /'
        fi
        return 1
    fi

    return 0
}

# Function to check for unpushed commits
check_unpushed_commits() {
    local dir="$1"

    cd "$dir"

    # Get current branch
    local current_branch
    current_branch=$(git rev-parse --abbrev-ref HEAD)

    # Check if branch has upstream
    local upstream
    upstream=$(git rev-parse --abbrev-ref --symbolic-full-name "@{u}" 2>/dev/null || echo "")

    if [[ -z "$upstream" ]]; then
        echo -e "${YELLOW}  ‚ö†Ô∏è  No upstream branch set for '$current_branch'${NC}"
        return 1
    fi

    # Check for unpushed commits
    local unpushed_count
    unpushed_count=$(git rev-list --count HEAD ^"$upstream" 2>/dev/null || echo "0")

    if [[ "$unpushed_count" -gt 0 ]]; then
        echo -e "${YELLOW}  ‚ö†Ô∏è  $unpushed_count unpushed commit(s) on '$current_branch'${NC}"
        if [[ "$VERBOSE" == true ]]; then
            echo "      Recent unpushed commits:"
            git log --oneline HEAD ^"$upstream" | head -5 | sed 's/^/        /'
        fi
        return 1
    fi

    return 0
}

# Function to process a single repository
process_repo() {
    local dir="$1"
    local repo_name
    repo_name=$(basename "$dir")

    echo -e "${BLUE}üìÅ $repo_name${NC}"

    local has_issues=false

    # Check for uncommitted changes
    if ! check_uncommitted_changes "$dir"; then
        has_issues=true
    fi

    # Check for unpushed commits if requested
    if [[ "$CHECK_PUSH" == true ]]; then
        if ! check_unpushed_commits "$dir"; then
            has_issues=true
        fi
    fi

    # Show clean status if no issues
    if [[ "$has_issues" == false ]]; then
        echo -e "${GREEN}  ‚úÖ Clean${NC}"
    fi

    echo ""
}

# Main execution
echo -e "${BLUE}üîç Scanning for git repositories in: $TARGET_DIR${NC}"
echo ""

# Counter for statistics
total_repos=0
clean_repos=0
repos_with_issues=0

# Find all directories and check if they're git repositories
while IFS= read -r -d '' dir; do
    if is_git_repo "$dir"; then
        ((total_repos++))

        # Process the repository
        if process_repo "$dir"; then
            ((clean_repos++))
        else
            ((repos_with_issues++))
        fi
    fi
done < <(find "$TARGET_DIR" -depth 1 -type d -print0)

# Print summary
echo -e "${BLUE}üìä Summary:${NC}"
echo "  Total repositories found: $total_repos"
echo -e "  Clean repositories: ${GREEN}$clean_repos${NC}"
echo -e "  Repositories with issues: ${YELLOW}$repos_with_issues${NC}"

# Exit with appropriate code
if [[ $repos_with_issues -gt 0 ]]; then
    exit 1
else
    exit 0
fi
