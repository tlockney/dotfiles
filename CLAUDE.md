# CLAUDE.md

<overview>
This is a dotfiles repository managed with YADM (Yet Another Dotfiles Manager). This file provides guidance to Claude Code when working with configuration files and shell scripts in this repository.
</overview>

<context>
YADM is a dotfiles manager that uses git under the hood but provides additional features for managing configuration files across different systems. Unlike typical code repositories, dotfiles repos don't have standard build processes but focus on system configuration management.
</context>

<commands>
<critical>
**IMPORTANT: yadm vs git**
- `yadm` commands ONLY work when running from the home directory (~/)
- When working in a git checkout (like /Users/tlockney/src/personal/yadm-dotfiles), you MUST use standard `git` commands instead
- Check the current working directory - if it's NOT the home directory, use `git`, not `yadm`
</critical>

<primary>
When in home directory (~):
- `yadm status` - Check status of tracked dotfiles
- `yadm add <file>` - Track new dotfiles
- `yadm commit -m "message"` - Commit changes

When in git checkout (/path/to/yadm-dotfiles):
- `git status` - Check status
- `git add <file>` - Stage files
- `git commit -m "message"` - Commit changes

Tool management commands:
- `bootstrap` - Fresh system setup (installs uv and runs Ansible playbook)
- `tool-update` - Update all installed tools
- `tool-update --check` - See what would be updated (dry-run)
- `tool-update --dev` - Update with dev tools included
- `tool-update --tags X` - Update specific category (homebrew, mise, rust, etc.)
- `tool-manager` - DEPRECATED legacy wrapper (use bootstrap or tool-update)
</primary>

<note>
No standard build/lint/test commands exist - this is a configuration repository, not a build artifact.

Tool management is now handled via Ansible playbook (`.config/dotfiles/playbook.yml`) with runtime versions defined in `.mise.toml`.
</note>
</commands>

<conventions>
<shell_scripts>
- Use bash for scripts with proper error handling (`set -euo pipefail`)
- Use descriptive variable/function names (e.g., `prepend_to_path`)
- Add command explanations in comments for complex operations
- Check for command existence using `command -v` (POSIX-compliant)
- Use 4-space indentation
- All scripts in bin/ should start with `#!/usr/bin/env bash` and `set -euo pipefail`
</shell_scripts>

<zsh_config>
- Modular structure: config files split into ~/.config/zsh/
  - init.zsh - Basic setup, completion system, keybindings
  - path.zsh - PATH manipulation
  - history.zsh - History configuration
  - completions.zsh - Completion styles
  - prompt.zsh - Prompt configuration
  - tools.zsh - Tool initialization and environment
  - aliases.zsh - Shell aliases
- Use 2-space indentation
- Main .zshrc simply loads the modular files
- Completions managed by ~/.config/zsh/update-completions.sh (not generated on every shell startup)
</zsh_config>

<cross_platform>
- Use platform-specific conditionals when needed
- Example: `if [ "$CURRENT_OS" = "Darwin" ]`
- Test commands exist before execution using `command -v`
- Provide fallbacks for missing tools
- Shared profile settings in ~/.config/shell/common-profile.sh (sourced by both .profile and .zprofile)
</cross_platform>

<linting>
- Use shellcheck for linting all shell scripts
- Run `bin/lint-shell` to check all scripts
- Shellcheck is installed via setup-tools
</linting>
</conventions>

<guidelines>
<when condition="adding new dotfiles">
1. Test the configuration on a clean system first
2. Use `yadm add` (from ~/) or `git add` (from git checkout) to track the file
3. Include relevant documentation in comments
4. Consider cross-platform compatibility
</when>

<when condition="modifying shell scripts">
1. Maintain existing error handling patterns
2. Preserve backward compatibility where possible
3. Test on both macOS and Linux if applicable
4. Update this documentation if adding new conventions
</when>

<when condition="updating tools">
1. Use `tool-update` for regular updates or `tool-update --check` to preview changes
2. For fresh system setup, use `bootstrap`
3. To add new tools, edit `.config/dotfiles/playbook.yml`
4. To change runtime versions, edit `.mise.toml` (e.g., node = "22" for latest 22.x)
5. Verify tools work after updates
6. Document any breaking changes in commit messages
7. Shell completions are automatically regenerated by the playbook
</when>

<when condition="adding new tools">
1. Edit `.config/dotfiles/playbook.yml` to add the tool installation task
2. Tag the task appropriately (setup, tool category, dev if optional)
3. Use shell commands for simplicity (avoid Ansible collection dependencies)
4. Test with `tool-update --check` first, then run `tool-update`
5. Update this documentation if adding a new tool category
</when>

<when condition="linting shell scripts">
1. Run `~/bin/lint-shell` to check all shell scripts
2. Fix any issues reported by shellcheck
3. Ensure all new scripts follow the error handling standard (`set -euo pipefail`)
</when>
</guidelines>

<examples>
<proper_error_handling>
```bash
#!/bin/bash
set -e  # Exit on any error

if ! type brew &>/dev/null; then
	echo "Homebrew not found, skipping brew operations"
	exit 0
fi
```
</proper_error_handling>

<cross_platform_check>
```bash
if test $CURRENT_OS = "Darwin"; then
	# macOS-specific operations
	export PATH="/opt/homebrew/bin:$PATH"
else
	# Linux-specific operations
	export PATH="/home/linuxbrew/.linuxbrew/bin:$PATH"
fi
```
</cross_platform_check>

<tool_management_examples>
```bash
# Update all tools
tool-update

# Preview what would be updated
tool-update --check

# Update only Homebrew packages
tool-update --tags homebrew

# Update mise and its managed runtimes
tool-update --tags mise

# Include dev tools in update
tool-update --dev

# Fresh system setup
bootstrap

# Fresh system setup with dev tools
bootstrap --dev
```
</tool_management_examples>

<mise_version_constraints>
```toml
# .mise.toml - Runtime version constraints
[tools]
node = "22"           # Latest 22.x (major version lock)
deno = "2"            # Latest 2.x
python = "3.12"       # Latest 3.12.x (major.minor lock)
go = "latest"         # Always latest stable
```
</mise_version_constraints>
</examples>
