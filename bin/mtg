#!/usr/bin/env bash

set -euo pipefail

SCRIPT_NAME="$(basename "$0")"
SCRIPT_PATH="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)/$(basename "${BASH_SOURCE[0]}")"

# --- Configuration ---
CAL_FILE="$HOME/.local/var/cal_agenda.json"
VAULT_PATH="$HOME/Obsidian/Personal"
MEETINGS_DIR="$VAULT_PATH/Active/Metron/Meetings"
CALENDAR_FILTER="Work Calendar"
SELF_NAME="Thomas Lockney"

# --- State ---
JSON_MODE=false
QUERY=""
TARGET_DATE="$(date +%Y-%m-%d)"
EVENT_UID=""

# --- Colors (disabled in JSON mode) ---
RED='\033[0;31m'
GREEN='\033[0;32m'
BLUE='\033[0;34m'
YELLOW='\033[0;33m'
BOLD='\033[1m'
NC='\033[0m'

# --- Logging ---
info()    { [[ "$JSON_MODE" == "true" ]] && return; echo -e "${BLUE}$*${NC}"; }
success() { [[ "$JSON_MODE" == "true" ]] && return; echo -e "${GREEN}$*${NC}"; }
warn()    { [[ "$JSON_MODE" == "true" ]] && return; echo -e "${YELLOW}$*${NC}" >&2; }
error() {
    if [[ "$JSON_MODE" == "true" ]]; then
        jq -n --arg m "$*" '{"items": [{"title": "Error", "subtitle": $m, "valid": false}]}'
        exit 0
    else
        echo -e "${RED}Error: $*${NC}" >&2
        exit 1
    fi
}

# --- Utilities ---

# Convert UTC ISO 8601 timestamp to local time
utc_to_local() {
    local utc_time="$1"
    local format="${2:-%Y-%m-%d %H:%M}"
    local epoch
    epoch=$(TZ=UTC date -jf "%Y-%m-%dT%H:%M:%SZ" "$utc_time" "+%s" 2>/dev/null) || return 1
    date -r "$epoch" "+$format"
}

# Sanitize a string for use as a filename
sanitize_filename() {
    echo "$1" | sed 's/1:1/1-1/g; s/://g; s|/| - |g; s/[\\<>"|?*]//g; s/  */ /g; s/^ *//; s/ *$//'
}

# Detect meeting type from title and invitee count
detect_meeting_type() {
    local title="$1"
    local invitee_count="$2"
    local lower
    lower=$(echo "$title" | tr '[:upper:]' '[:lower:]')

    if [[ "$lower" =~ 1:1|1-1|1on1|one-on-one ]]; then
        echo "1-1"
    elif [[ "$invitee_count" -le 1 ]]; then
        echo "1-1"
    elif [[ "$lower" =~ standup|stand-up|daily\ scrum ]]; then
        echo "standup"
    elif [[ "$lower" =~ grooming|refinement ]]; then
        echo "grooming"
    elif [[ "$lower" =~ sprint.*planning|planning.*sprint ]]; then
        echo "planning"
    elif [[ "$lower" =~ retro(spective)? ]]; then
        echo "retro"
    fi
}

# Verify required tools are available
check_deps() {
    local missing=()
    command -v jq >/dev/null 2>&1 || missing+=("jq")
    [[ "$JSON_MODE" != "true" ]] && { command -v fzf >/dev/null 2>&1 || missing+=("fzf"); }
    if [[ ${#missing[@]} -gt 0 ]]; then
        error "Missing required dependencies: ${missing[*]}"
    fi
}

# --- Data ---

# Get events for a target date, filtered to the configured calendar
get_events() {
    local target_date="$1"
    [[ ! -f "$CAL_FILE" ]] && error "Calendar file not found: $CAL_FILE"

    local all_events
    all_events=$(jq -c --arg cal "$CALENDAR_FILTER" '
        .events
        | map(select(.calendar == $cal and .all_day == false))
        | sort_by(.start)
        | .[]
    ' "$CAL_FILE" 2>/dev/null) || error "Failed to parse calendar file"

    # Filter by local date (UTC times may fall on different local dates)
    local filtered=()
    while IFS= read -r event; do
        [[ -z "$event" ]] && continue
        local start_utc local_date
        start_utc=$(echo "$event" | jq -r '.start')
        local_date=$(utc_to_local "$start_utc" "%Y-%m-%d") || continue
        [[ "$local_date" == "$target_date" ]] && filtered+=("$event")
    done <<< "$all_events"

    if [[ ${#filtered[@]} -eq 0 ]]; then
        echo "[]"
    else
        printf '%s\n' "${filtered[@]}" | jq -s '.'
    fi
}

# Look up a single event by its calendar UID
get_event_by_uid() {
    local uid="$1"
    jq -c --arg uid "$uid" '.events | map(select(.uid == $uid)) | first // empty' "$CAL_FILE"
}

# Get invitee names (excluding self) as a JSON array
get_invitees() {
    local event="$1"
    echo "$event" | jq --arg self "$SELF_NAME" '
        (
            [(.attendees // [])[].name] +
            [.organizer.name // empty]
        ) |
        map(select(. != $self and . != null)) |
        unique
    '
}

# Format a single event for terminal display
format_event_display() {
    local event="$1"
    local start_utc end_utc title
    start_utc=$(echo "$event" | jq -r '.start')
    end_utc=$(echo "$event" | jq -r '.end')
    title=$(echo "$event" | jq -r '.title')

    local invitees invitee_count
    invitees=$(get_invitees "$event")
    invitee_count=$(echo "$invitees" | jq 'length')

    local start_time end_time
    start_time=$(utc_to_local "$start_utc" "%H:%M")
    end_time=$(utc_to_local "$end_utc" "%H:%M")

    if [[ "$invitee_count" -eq 1 ]]; then
        printf "%s - %s  %s (1 invitee)" "$start_time" "$end_time" "$title"
    else
        printf "%s - %s  %s (%d invitees)" "$start_time" "$end_time" "$title" "$invitee_count"
    fi
}

# Open a meeting note in Obsidian
open_in_obsidian() {
    local filename="$1"
    local note_name="${filename%.md}"
    local encoded
    encoded=$(python3 -c "import urllib.parse; print(urllib.parse.quote('Active/Metron/Meetings/$note_name'))")
    open "obsidian://open?vault=Personal&file=$encoded" 2>/dev/null || true
}

# --- Commands ---

# Internal fzf subcommands for day navigation

# Output UID\tdisplay lines for the date stored in a datefile
# Uses a single python3 call for speed (avoids per-event subprocess spawning)
cmd_fzf_data() {
    local datefile="$1"
    local target_date
    target_date=$(cat "$datefile")

    python3 - "$CAL_FILE" "$target_date" "$CALENDAR_FILTER" "$SELF_NAME" <<'PYEOF'
import json, sys
from datetime import datetime

cal_file, target, cal_filter, self_name = sys.argv[1:5]

with open(cal_file) as f:
    data = json.load(f)

events = [e for e in data["events"]
          if e.get("calendar") == cal_filter and not e.get("all_day", False)]
events.sort(key=lambda e: e["start"])

for event in events:
    start = datetime.fromisoformat(event["start"]).astimezone()
    if start.strftime("%Y-%m-%d") != target:
        continue
    end = datetime.fromisoformat(event["end"]).astimezone()

    names = set()
    for a in event.get("attendees", []):
        name = a.get("name")
        if name and name != self_name:
            names.add(name)
    org = (event.get("organizer") or {}).get("name")
    if org and org != self_name:
        names.add(org)

    n = len(names)
    label = "1 invitee" if n == 1 else f"{n} invitees"
    st = start.strftime("%H:%M")
    et = end.strftime("%H:%M")

    print(f"{event['uid']}\t{st} - {et}  {event['title']} ({label})")
PYEOF
}

# Navigate to previous or next day, updating the datefile
cmd_fzf_nav() {
    local direction="$1"
    local datefile="$2"
    local current_date new_date
    current_date=$(cat "$datefile")
    if [[ "$direction" == "prev" ]]; then
        new_date=$(date -v-1d -jf "%Y-%m-%d" "$current_date" "+%Y-%m-%d")
    else
        new_date=$(date -v+1d -jf "%Y-%m-%d" "$current_date" "+%Y-%m-%d")
    fi
    echo "$new_date" > "$datefile"
}

# Output the fzf header for the current date
cmd_fzf_header() {
    local datefile="$1"
    local current_date day_name
    current_date=$(cat "$datefile")
    day_name=$(date -jf "%Y-%m-%d" "$current_date" "+%A")
    echo "$day_name $current_date  |  ← prev day  ·  next day →"
}

# Preview command for fzf (called internally)
cmd_preview() {
    local uid="$1"
    local event
    event=$(get_event_by_uid "$uid")
    [[ -z "$event" ]] && { echo "Event not found"; return; }

    local title start_utc end_utc location organizer_name recurring
    title=$(echo "$event" | jq -r '.title')
    start_utc=$(echo "$event" | jq -r '.start')
    end_utc=$(echo "$event" | jq -r '.end')
    location=$(echo "$event" | jq -r '.location // ""')
    organizer_name=$(echo "$event" | jq -r '.organizer.name // ""')
    recurring=$(echo "$event" | jq -r '.recurring // false')

    local start_time end_time local_date
    local_date=$(utc_to_local "$start_utc" "%Y-%m-%d")
    start_time=$(utc_to_local "$start_utc" "%H:%M")
    end_time=$(utc_to_local "$end_utc" "%H:%M")

    local invitees_json invitee_count meeting_type
    invitees_json=$(get_invitees "$event")
    invitee_count=$(echo "$invitees_json" | jq 'length')
    meeting_type=$(detect_meeting_type "$title" "$invitee_count")

    echo -e "${BOLD}${title}${NC}"
    echo
    echo -e "  Date:       $local_date"
    echo -e "  Time:       $start_time - $end_time"
    [[ -n "$meeting_type" ]] && echo -e "  Type:       $meeting_type"

    # Check recurring: either the event itself or its parent (via /RID= UID)
    local is_recurring="$recurring"
    if [[ "$is_recurring" != "true" ]]; then
        local event_uid
        event_uid=$(echo "$event" | jq -r '.uid')
        if [[ "$event_uid" == *"/RID="* ]]; then
            local base_uid="${event_uid%%/RID=*}"
            is_recurring=$(jq -r --arg uid "$base_uid" \
                '.events[] | select(.uid == $uid) | .recurring // false' "$CAL_FILE" 2>/dev/null | head -1)
        fi
    fi
    [[ "$is_recurring" == "true" ]] && echo -e "  Recurring:  yes"
    [[ -n "$location" ]] && echo -e "  Location:   $location"
    [[ -n "$organizer_name" && "$organizer_name" != "$SELF_NAME" ]] && echo -e "  Organizer:  $organizer_name"
    echo
    echo -e "${BOLD}Invitees ($invitee_count):${NC}"
    while IFS= read -r name; do
        echo "  - $name"
    done < <(echo "$invitees_json" | jq -r '.[]')

    # Check if note already exists
    local safe_title filename filepath
    safe_title=$(sanitize_filename "$title")
    filename="${safe_title} - ${local_date}.md"
    filepath="$MEETINGS_DIR/$filename"
    if [[ -f "$filepath" ]]; then
        echo
        echo -e "${YELLOW}Note already exists${NC}"
    fi
}

show_help() {
    cat <<EOF
Usage: $SCRIPT_NAME [command] [options]

Commands:
    list   (l)   List meetings for today (or specified date)
    create (c)   Create a meeting note
    help         Show this help

    If no command is given, interactively select a meeting and create a note.

Options:
    --date DATE   Target date in YYYY-MM-DD format (default: today)
    --json        Output as Alfred-compatible JSON (list command only)
    -q QUERY      Filter meetings by query (with --json)
    --uid UID     Specify meeting by calendar UID (create command)
    --help        Show this help

Examples:
    $SCRIPT_NAME                           # Interactive: pick meeting & create note
    $SCRIPT_NAME l                         # List today's meetings
    $SCRIPT_NAME list --date 2026-03-01    # List meetings for a specific date
    $SCRIPT_NAME list --json               # JSON output for Alfred
    $SCRIPT_NAME list --json -q standup    # Alfred JSON filtered by query
    $SCRIPT_NAME c                         # Interactively create a meeting note
    $SCRIPT_NAME create --uid ABC-123      # Create note for a specific meeting UID
EOF
    exit 0
}

cmd_list() {
    check_deps

    local events
    events=$(get_events "$TARGET_DATE")
    local count
    count=$(echo "$events" | jq 'length')

    if [[ "$count" -eq 0 ]]; then
        if [[ "$JSON_MODE" == "true" ]]; then
            jq -n --arg d "$TARGET_DATE" \
                '{"items": [{"title": "No meetings", "subtitle": ("No meetings found for " + $d), "valid": false}]}'
        else
            info "No meetings found for $TARGET_DATE"
        fi
        return
    fi

    if [[ "$JSON_MODE" == "true" ]]; then
        echo '{"items": ['
        local first=true
        while IFS= read -r event; do
            local title uid start_utc end_utc start_time end_time invitee_count
            title=$(echo "$event" | jq -r '.title')
            uid=$(echo "$event" | jq -r '.uid')
            start_utc=$(echo "$event" | jq -r '.start')
            end_utc=$(echo "$event" | jq -r '.end')
            start_time=$(utc_to_local "$start_utc" "%H:%M")
            end_time=$(utc_to_local "$end_utc" "%H:%M")
            invitee_count=$(echo "$event" | jq --arg self "$SELF_NAME" \
                '[(.attendees // [])[].name] | map(select(. != $self)) | length')

            # Filter by query if provided
            if [[ -n "$QUERY" ]]; then
                local lower_title lower_query
                lower_title=$(echo "$title" | tr '[:upper:]' '[:lower:]')
                lower_query=$(echo "$QUERY" | tr '[:upper:]' '[:lower:]')
                [[ "$lower_title" != *"$lower_query"* ]] && continue
            fi

            [[ "$first" != "true" ]] && echo ","
            first=false

            jq -n \
                --arg uid "$uid" \
                --arg title "$title" \
                --arg subtitle "$start_time - $end_time • $invitee_count invitees" \
                '{
                    "uid": $uid,
                    "title": $title,
                    "subtitle": $subtitle,
                    "arg": $uid,
                    "autocomplete": $title
                }'
        done < <(echo "$events" | jq -c '.[]')
        echo ']}'
    else
        info "Meetings for $TARGET_DATE:"
        echo
        while IFS= read -r event; do
            echo "  $(format_event_display "$event")"
        done < <(echo "$events" | jq -c '.[]')
    fi
}

cmd_create() {
    check_deps

    local event=""

    if [[ -n "$EVENT_UID" ]]; then
        event=$(get_event_by_uid "$EVENT_UID")
        [[ -z "$event" ]] && error "No event found with UID: $EVENT_UID"
    else
        # Interactive selection via fzf with day navigation
        local datefile
        datefile=$(mktemp)
        trap "rm -f '$datefile'" EXIT
        echo "$TARGET_DATE" > "$datefile"

        # Generate initial data
        local fzf_input
        fzf_input=$("$SCRIPT_PATH" _fzf-data "$datefile")
        local initial_header
        initial_header=$("$SCRIPT_PATH" _fzf-header "$datefile")

        local bind_prev="left:execute-silent(${SCRIPT_PATH} _fzf-nav prev ${datefile})+reload(${SCRIPT_PATH} _fzf-data ${datefile})+transform-header(${SCRIPT_PATH} _fzf-header ${datefile})"
        local bind_next="right:execute-silent(${SCRIPT_PATH} _fzf-nav next ${datefile})+reload(${SCRIPT_PATH} _fzf-data ${datefile})+transform-header(${SCRIPT_PATH} _fzf-header ${datefile})"

        local selected
        selected=$(echo "$fzf_input" | fzf \
            --height=80% \
            --layout=reverse \
            --border \
            --delimiter=$'\t' \
            --with-nth=2 \
            --preview "'$SCRIPT_PATH' _preview {1}" \
            --preview-window=right:50%:wrap \
            --bind "$bind_prev" \
            --bind "$bind_next" \
            --prompt="Select meeting: " \
            --header="$initial_header") || { echo "Cancelled."; exit 0; }

        local selected_uid
        selected_uid=$(echo "$selected" | cut -f1)
        event=$(get_event_by_uid "$selected_uid")
        [[ -z "$event" ]] && error "Failed to find selected meeting"
    fi

    # --- Extract event details ---
    local title start_utc end_utc location organizer_name recurring
    title=$(echo "$event" | jq -r '.title')
    start_utc=$(echo "$event" | jq -r '.start')
    end_utc=$(echo "$event" | jq -r '.end')
    location=$(echo "$event" | jq -r '.location // ""')
    organizer_name=$(echo "$event" | jq -r '.organizer.name // ""')
    recurring=$(echo "$event" | jq -r '.recurring // false')

    local local_date start_time end_time
    local_date=$(utc_to_local "$start_utc" "%Y-%m-%d")
    start_time=$(utc_to_local "$start_utc" "%H:%M")
    end_time=$(utc_to_local "$end_utc" "%H:%M")

    local invitees_json invitee_count
    invitees_json=$(get_invitees "$event")
    invitee_count=$(echo "$invitees_json" | jq 'length')

    local meeting_type
    meeting_type=$(detect_meeting_type "$title" "$invitee_count")

    # Detect series: check event's own flag, or if UID has /RID= it's a
    # recurring instance — look up the parent event's recurring flag
    local series=""
    if [[ "$recurring" == "true" ]]; then
        series="$title"
    elif [[ "$EVENT_UID" == *"/RID="* ]]; then
        local base_uid="${EVENT_UID%%/RID=*}"
        local parent_recurring
        parent_recurring=$(jq -r --arg uid "$base_uid" \
            '.events[] | select(.uid == $uid) | .recurring // false' "$CAL_FILE" 2>/dev/null | head -1)
        [[ "$parent_recurring" == "true" ]] && series="$title"
    else
        # Also check if UID from fzf selection was a recurring instance
        local event_uid
        event_uid=$(echo "$event" | jq -r '.uid')
        if [[ "$event_uid" == *"/RID="* ]]; then
            local base_uid="${event_uid%%/RID=*}"
            local parent_recurring
            parent_recurring=$(jq -r --arg uid "$base_uid" \
                '.events[] | select(.uid == $uid) | .recurring // false' "$CAL_FILE" 2>/dev/null | head -1)
            [[ "$parent_recurring" == "true" ]] && series="$title"
        fi
    fi

    # --- Build file path ---
    local safe_title filename filepath
    safe_title=$(sanitize_filename "$title")
    filename="${safe_title} - ${local_date}.md"
    filepath="$MEETINGS_DIR/$filename"

    # Check for existing note
    if [[ -f "$filepath" ]]; then
        warn "Note already exists: $filename"
        if [[ "$JSON_MODE" != "true" ]] && [[ -t 0 ]]; then
            read -rp "Open existing note? [Y/n] " answer
            if [[ "${answer:-Y}" =~ ^[Yy]$ ]]; then
                open_in_obsidian "$filename"
            fi
        fi
        return
    fi

    mkdir -p "$MEETINGS_DIR"

    # --- Write note ---
    {
        echo "---"
        echo "tags:"
        echo "  - meeting"
        echo "date: $local_date"
        echo "start-time: \"$start_time\""
        echo "end-time: \"$end_time\""

        if [[ -n "$series" ]]; then
            echo "series: \"$series\""
        fi

        if [[ -n "$meeting_type" ]]; then
            echo "meeting-type: $meeting_type"
        fi

        echo "invitees:"
        while IFS= read -r name; do
            echo "  - $name"
        done < <(echo "$invitees_json" | jq -r '.[]')

        if [[ -n "$organizer_name" && "$organizer_name" != "$SELF_NAME" ]]; then
            echo "organizer: $organizer_name"
        fi

        if [[ -n "$location" ]]; then
            echo "location: \"$location\""
        fi

        echo "calendar: $CALENDAR_FILTER"
        echo "---"
        echo
        echo "# $title"
        echo
        echo "## Attendees"
        while IFS= read -r name; do
            echo "- [[$name]]"
        done < <(echo "$invitees_json" | jq -r '.[]')
        echo
        echo "## Notes"
        echo
        echo "## Summary"
        echo
        echo "## Action Items"
        echo "- [ ] "
    } > "$filepath"

    success "Created: $filename"
    open_in_obsidian "$filename"
}

# --- Option Parsing ---

parse_options() {
    while [[ $# -gt 0 ]]; do
        case $1 in
            --help)
                show_help
                ;;
            --date)
                [[ $# -lt 2 ]] && error "--date requires a YYYY-MM-DD argument"
                TARGET_DATE="$2"
                shift 2
                ;;
            --json)
                JSON_MODE=true
                shift
                ;;
            -q)
                [[ $# -lt 2 ]] && error "-q requires a query string"
                QUERY="$2"
                shift 2
                ;;
            --uid)
                [[ $# -lt 2 ]] && error "--uid requires a UID argument"
                EVENT_UID="$2"
                shift 2
                ;;
            -*)
                error "Unknown option: $1"
                ;;
            *)
                error "Unexpected argument: $1"
                ;;
        esac
    done
}

# --- Main ---

main() {
    if [[ $# -lt 1 ]]; then
        cmd_create
        return
    fi

    local command="$1"
    shift

    case "$command" in
        l|list)     parse_options "$@"; cmd_list ;;
        c|create)   parse_options "$@"; cmd_create ;;
        _preview)   cmd_preview "$@" ;;
        _fzf-data)  cmd_fzf_data "$@" ;;
        _fzf-nav)   cmd_fzf_nav "$@" ;;
        _fzf-header) cmd_fzf_header "$@" ;;
        help|--help) show_help ;;
        -*)         parse_options "$command" "$@"; cmd_create ;;
        *)          error "Unknown command: $command. Use '$SCRIPT_NAME help' for usage." ;;
    esac
}

main "$@"
