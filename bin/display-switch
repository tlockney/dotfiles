#!/usr/bin/env -S deno run --allow-run --allow-read --allow-write --allow-net --allow-env

/**
 * display-switch — Multi-monitor display mode switcher
 *
 * Switches Dell U4025QW and BenQ MA320U inputs via BetterDisplay CLI (DDC).
 * Optionally connects to an MQTT broker for Home Assistant integration.
 *
 * When dell_host is configured, Dell DDC commands are sent via BetterDisplay's
 * HTTP API to the MBP (which has a Thunderbolt connection that supports DDC
 * regardless of active input). BenQ commands always run locally.
 *
 * Usage:
 *   ./display-switch.ts <command>
 *
 * Commands:
 *   init           Generate default config file
 *   status         Detect current mode from display inputs
 *   serve          Connect to MQTT broker and listen for commands
 *   work           Both displays → MBP
 *   split-air      Dell → MBP, BenQ → Air
 *   split-mini     Dell → MBP, BenQ → Mini
 *   nonwork        Both displays → Mini
 *   nonwork-air    Dell → Mini, BenQ → Air
 */

import { connect } from "npm:mqtt@5";
import { join } from "https://deno.land/std@0.224.0/path/mod.ts";

// ---------------------------------------------------------------------------
// Config
// ---------------------------------------------------------------------------

interface Config {
  ddc: {
    dell_tb: number;
    dell_hdmi: number;
    benq_hdmi1: number;
    benq_hdmi2: number;
    benq_usbc: number;
  };
  // BetterDisplay HTTP endpoint for Dell DDC (e.g. "mbp.local:55777").
  // When set, Dell commands are sent via HTTP to this host instead of local CLI.
  // Leave empty to use local CLI (when running on the MBP itself).
  dell_host: string;
  mqtt: {
    broker: string;
    port: number;
    username: string;
    password: string;
    topic_prefix: string;
  };
  poll_interval_seconds: number;
}

const DEFAULT_CONFIG: Config = {
  ddc: {
    dell_tb: 25,
    dell_hdmi: 17,
    benq_hdmi1: 17,
    benq_hdmi2: 18,
    benq_usbc: 15,
  },
  dell_host: "",
  mqtt: {
    broker: "localhost",
    port: 1883,
    username: "",
    password: "",
    topic_prefix: "display-switch",
  },
  poll_interval_seconds: 30,
};

function configDir(): string {
  const home = Deno.env.get("HOME") ?? "~";
  return join(home, ".config", "display-switch");
}

function configPath(): string {
  return join(configDir(), "config.json");
}

async function loadConfig(): Promise<Config> {
  try {
    const text = await Deno.readTextFile(configPath());
    const parsed = JSON.parse(text);
    return {
      ...DEFAULT_CONFIG,
      ...parsed,
      ddc: { ...DEFAULT_CONFIG.ddc, ...parsed.ddc },
      mqtt: { ...DEFAULT_CONFIG.mqtt, ...parsed.mqtt },
    };
  } catch {
    return DEFAULT_CONFIG;
  }
}

async function initConfig(): Promise<void> {
  const dir = configDir();
  await Deno.mkdir(dir, { recursive: true });

  const path = configPath();
  try {
    await Deno.lstat(path);
    console.log(`Config already exists: ${path}`);
    console.log("Delete it first if you want to regenerate.");
    return;
  } catch {
    // File doesn't exist, proceed
  }

  await Deno.writeTextFile(path, JSON.stringify(DEFAULT_CONFIG, null, 2) + "\n");
  console.log(`Config written to ${path}`);
  console.log("Edit the DDC values and MQTT settings, then run: display-switch.ts serve");
}

// ---------------------------------------------------------------------------
// Modes
// ---------------------------------------------------------------------------

interface Mode {
  dell: number;
  benq: number;
  desc: string;
}

function buildModes(config: Config): Record<string, Mode> {
  const { ddc } = config;
  return {
    "work":        { dell: ddc.dell_tb,   benq: ddc.benq_hdmi1, desc: "Both → MBP" },
    "split-air":   { dell: ddc.dell_tb,   benq: ddc.benq_usbc,  desc: "Dell → MBP, BenQ → Air" },
    "split-mini":  { dell: ddc.dell_tb,   benq: ddc.benq_hdmi2, desc: "Dell → MBP, BenQ → Mini" },
    "nonwork":     { dell: ddc.dell_hdmi, benq: ddc.benq_hdmi2, desc: "Both → Mini" },
    "nonwork-air": { dell: ddc.dell_hdmi, benq: ddc.benq_usbc,  desc: "Dell → Mini, BenQ → Air" },
  };
}

// ---------------------------------------------------------------------------
// DDC control — local CLI
// ---------------------------------------------------------------------------

async function getInputLocal(monitorName: string): Promise<number | null> {
  const cmd = new Deno.Command("betterdisplaycli", {
    args: ["get", `-nameLike=${monitorName}`, "-ddc", "-vcp=inputSelect", "-value"],
    stdout: "piped",
    stderr: "piped",
  });

  const { code, stdout } = await cmd.output();
  if (code !== 0) return null;

  const output = new TextDecoder().decode(stdout).trim();
  if (output === "" || output.startsWith("Failed")) return null;

  const raw = parseInt(output, 10);
  if (isNaN(raw)) return null;

  // betterdisplaycli returns a packed 16-bit value (high byte = low byte = input code)
  return raw & 0xFF;
}

async function setInputLocal(monitorName: string, value: number): Promise<void> {
  const cmd = new Deno.Command("betterdisplaycli", {
    args: ["set", `-nameLike=${monitorName}`, "-ddc", "-vcp=0x60", `-value=${value}`],
    stdout: "piped",
    stderr: "piped",
  });

  const { code, stderr } = await cmd.output();
  if (code !== 0) {
    const err = new TextDecoder().decode(stderr);
    throw new Error(`Failed to set ${monitorName} to ${value}: ${err}`);
  }
}

// ---------------------------------------------------------------------------
// DDC control — remote via BetterDisplay HTTP API
// ---------------------------------------------------------------------------

async function getInputRemote(host: string, monitorName: string): Promise<number | null> {
  try {
    const url = `http://${host}/get?nameLike=${monitorName}&ddc&vcp=inputSelect&value`;
    const resp = await fetch(url);
    if (!resp.ok) return null;

    const output = (await resp.text()).trim();
    if (output === "" || output.startsWith("Failed")) return null;

    const raw = parseInt(output, 10);
    if (isNaN(raw)) return null;

    return raw & 0xFF;
  } catch {
    return null;
  }
}

async function setInputRemote(host: string, monitorName: string, value: number): Promise<void> {
  const url = `http://${host}/set?nameLike=${monitorName}&ddc&vcp=0x60&value=${value}`;
  const resp = await fetch(url);
  if (!resp.ok) {
    const err = await resp.text();
    throw new Error(`Failed to set ${monitorName} to ${value} via ${host}: ${err}`);
  }
}

// ---------------------------------------------------------------------------
// DDC control — routed based on config
// ---------------------------------------------------------------------------

async function getDellInput(config: Config): Promise<number | null> {
  if (config.dell_host) {
    return getInputRemote(config.dell_host, "dell");
  }
  return getInputLocal("dell");
}

async function setDellInput(config: Config, value: number): Promise<void> {
  if (config.dell_host) {
    return setInputRemote(config.dell_host, "dell", value);
  }
  return setInputLocal("dell", value);
}

async function getBenqInput(): Promise<number | null> {
  return getInputLocal("benq");
}

async function setBenqInput(value: number): Promise<void> {
  return setInputLocal("benq", value);
}

// ---------------------------------------------------------------------------
// Mode detection and switching
// ---------------------------------------------------------------------------

async function detectMode(config: Config, modes: Record<string, Mode>): Promise<string> {
  const [dell, benq] = await Promise.all([
    getDellInput(config),
    getBenqInput(),
  ]);

  if (dell === null && benq === null) return "unknown (both displays unreachable)";

  const match = Object.entries(modes).find(
    ([_, mode]) =>
      (dell === null || mode.dell === dell) &&
      (benq === null || mode.benq === benq)
  );

  if (match) return match[0];

  const parts = [
    dell !== null ? `dell=${dell}` : "dell=unreachable",
    benq !== null ? `benq=${benq}` : "benq=unreachable",
  ];
  return `unknown (${parts.join(", ")})`;
}

async function switchMode(
  modeName: string,
  config: Config,
  modes: Record<string, Mode>,
): Promise<void> {
  const mode = modes[modeName];
  if (!mode) {
    console.error(`Unknown mode: ${modeName}`);
    printUsage(modes);
    Deno.exit(1);
  }

  console.log(`Switching to "${modeName}" — ${mode.desc}`);

  await Promise.all([
    setDellInput(config, mode.dell),
    setBenqInput(mode.benq),
  ]);

  console.log("Done.");
}

// ---------------------------------------------------------------------------
// MQTT serve
// ---------------------------------------------------------------------------

async function serve(config: Config, modes: Record<string, Mode>): Promise<void> {
  const { mqtt: mqttConfig, poll_interval_seconds } = config;
  const commandTopic = `${mqttConfig.topic_prefix}/command`;
  const statusTopic = `${mqttConfig.topic_prefix}/status`;

  const url = `mqtt://${mqttConfig.broker}:${mqttConfig.port}`;
  const opts: Record<string, unknown> = {};
  if (mqttConfig.username) {
    opts.username = mqttConfig.username;
    opts.password = mqttConfig.password;
  }

  console.log(`Connecting to ${url}...`);
  const client = connect(url, opts);

  client.on("connect", () => {
    console.log(`Connected. Subscribing to ${commandTopic}`);
    client.subscribe(commandTopic);
    pollAndPublish(client, statusTopic, config, modes);
  });

  client.on("message", async (_topic: string, payload: Buffer) => {
    const requested = payload.toString().trim();
    console.log(`Received command: ${requested}`);

    if (!modes[requested]) {
      console.error(`Unknown mode: ${requested}`);
      return;
    }

    try {
      await switchMode(requested, config, modes);
      client.publish(statusTopic, requested, { retain: true });
    } catch (err) {
      console.error(`Switch failed: ${err}`);
    }
  });

  client.on("error", (err: Error) => {
    console.error(`MQTT error: ${err.message}`);
  });

  setInterval(
    () => pollAndPublish(client, statusTopic, config, modes),
    poll_interval_seconds * 1000,
  );

  // Keep alive
  await new Promise(() => {});
}

async function pollAndPublish(
  client: ReturnType<typeof connect>,
  topic: string,
  config: Config,
  modes: Record<string, Mode>,
): Promise<void> {
  try {
    const current = await detectMode(config, modes);
    client.publish(topic, current, { retain: true });
  } catch (err) {
    console.error(`Status poll failed: ${err}`);
  }
}

// ---------------------------------------------------------------------------
// CLI
// ---------------------------------------------------------------------------

function printUsage(modes: Record<string, Mode>): void {
  console.log(`
Usage: display-switch.ts <command>

Commands:
  init           Generate default config file
  status         Detect current mode from display inputs
  serve          Connect to MQTT broker and listen for commands
`);
  for (const [name, { desc }] of Object.entries(modes)) {
    console.log(`  ${name.padEnd(14)} ${desc}`);
  }
  console.log(`\nConfig: ${configPath()}`);
}

// ---------------------------------------------------------------------------
// Main
// ---------------------------------------------------------------------------

const config = await loadConfig();
const modes = buildModes(config);
const command = Deno.args[0];

if (!command || command === "--help" || command === "-h") {
  printUsage(modes);
  Deno.exit(0);
}

switch (command) {
  case "init":
    await initConfig();
    break;
  case "status": {
    const current = await detectMode(config, modes);
    console.log(current);
    break;
  }
  case "serve":
    await serve(config, modes);
    break;
  default:
    await switchMode(command, config, modes);
    break;
}