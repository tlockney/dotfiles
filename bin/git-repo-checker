#!/usr/bin/env bash

# Git Repository Status Checker
# Usage: git-repo-checker [directory] [options]
# Options:
#   -p, --check-push    Also check for unpushed commits
#   -v, --verbose       Show detailed output
#   -h, --help          Show this help message

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
# shellcheck source=lib/common.sh
source "$SCRIPT_DIR/lib/common.sh"

# Default values
TARGET_DIR="."
CHECK_PUSH=false
VERBOSE=false

# Function to print usage
show_help() {
    local name
    name=$(basename "$0")
    echo "Usage: $name [directory] [options]"
    echo ""
    echo "Scan a directory tree for git repos and report their status."
    echo ""
    echo "Options:"
    echo "  -p, --check-push    Also check for unpushed commits"
    echo "  -v, --verbose       Show detailed output"
    echo "  -h, --help          Show this help message"
    echo ""
    echo "Examples:"
    echo "  $name                           # Check current directory"
    echo "  $name /path/to/projects        # Check specific directory"
    echo "  $name ~/projects -p            # Check with push status"
    echo "  $name ~/projects -p -v         # Verbose with push status"
}

# Parse command line arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        -p|--check-push)
            CHECK_PUSH=true
            shift
            ;;
        -v|--verbose)
            VERBOSE=true
            shift
            ;;
        -h|--help)
            show_help
            exit 0
            ;;
        -*)
            echo "Unknown option $1"
            show_help
            exit 1
            ;;
        *)
            TARGET_DIR="$1"
            shift
            ;;
    esac
done

# Check if target directory exists
if [[ ! -d "$TARGET_DIR" ]]; then
    error "Directory '$TARGET_DIR' does not exist"
fi

# Function to check if directory is a git repository
is_git_repo() {
    local dir="$1"
    [[ -d "$dir/.git" ]] || git -C "$dir" rev-parse --git-dir >/dev/null 2>&1
}

# Function to check for uncommitted changes
check_uncommitted_changes() {
    local dir="$1"

    # Check for uncommitted changes
    if ! git -C "$dir" diff-index --quiet HEAD --; then
        echo -e "${YELLOW}  ‚ö†Ô∏è  Uncommitted changes found${NC}"
        if [[ "$VERBOSE" == true ]]; then
            echo "      Modified files:"
            git -C "$dir" diff-index --name-only HEAD -- | sed 's/^/        /'
        fi
        return 1
    fi

    # Check for untracked files
    if [[ -n $(git -C "$dir" ls-files --others --exclude-standard) ]]; then
        echo -e "${YELLOW}  ‚ö†Ô∏è  Untracked files found${NC}"
        if [[ "$VERBOSE" == true ]]; then
            echo "      Untracked files:"
            git -C "$dir" ls-files --others --exclude-standard | sed 's/^/        /'
        fi
        return 1
    fi

    # Check for staged changes
    if ! git -C "$dir" diff-index --quiet --cached HEAD --; then
        echo -e "${YELLOW}  ‚ö†Ô∏è  Staged changes found${NC}"
        if [[ "$VERBOSE" == true ]]; then
            echo "      Staged files:"
            git -C "$dir" diff-index --name-only --cached HEAD -- | sed 's/^/        /'
        fi
        return 1
    fi

    return 0
}

# Function to check for unpushed commits
check_unpushed_commits() {
    local dir="$1"

    # Get current branch
    local current_branch
    current_branch=$(git -C "$dir" rev-parse --abbrev-ref HEAD)

    # Check if branch has upstream
    local upstream
    upstream=$(git -C "$dir" rev-parse --abbrev-ref --symbolic-full-name "@{u}" 2>/dev/null || echo "")

    if [[ -z "$upstream" ]]; then
        echo -e "${YELLOW}  ‚ö†Ô∏è  No upstream branch set for '$current_branch'${NC}"
        return 1
    fi

    # Check for unpushed commits
    local unpushed_count
    unpushed_count=$(git -C "$dir" rev-list --count HEAD ^"$upstream" 2>/dev/null || echo "0")

    if [[ "$unpushed_count" -gt 0 ]]; then
        echo -e "${YELLOW}  ‚ö†Ô∏è  $unpushed_count unpushed commit(s) on '$current_branch'${NC}"
        if [[ "$VERBOSE" == true ]]; then
            echo "      Recent unpushed commits:"
            git -C "$dir" log --oneline HEAD ^"$upstream" | head -5 | sed 's/^/        /'
        fi
        return 1
    fi

    return 0
}

# Function to process a single repository
process_repo() {
    local dir="$1"
    local repo_name
    repo_name=$(basename "$dir")

    echo -e "${BLUE}üìÅ $repo_name${NC}"

    local has_issues=false

    # Check for uncommitted changes
    if ! check_uncommitted_changes "$dir"; then
        has_issues=true
    fi

    # Check for unpushed commits if requested
    if [[ "$CHECK_PUSH" == true ]]; then
        if ! check_unpushed_commits "$dir"; then
            has_issues=true
        fi
    fi

    # Show clean status if no issues
    if [[ "$has_issues" == false ]]; then
        echo -e "${GREEN}  ‚úÖ Clean${NC}"
    fi

    echo ""
}

# Main execution
echo -e "${BLUE}üîç Scanning for git repositories in: $TARGET_DIR${NC}"
echo ""

# Counter for statistics
total_repos=0
clean_repos=0
repos_with_issues=0

# Find all directories and check if they're git repositories
while IFS= read -r -d '' dir; do
    if is_git_repo "$dir"; then
        ((total_repos++))

        # Process the repository
        if process_repo "$dir"; then
            ((clean_repos++))
        else
            ((repos_with_issues++))
        fi
    fi
done < <(find "$TARGET_DIR" -maxdepth 1 -mindepth 1 -type d -print0)

# Print summary
echo -e "${BLUE}üìä Summary:${NC}"
echo "  Total repositories found: $total_repos"
echo -e "  Clean repositories: ${GREEN}$clean_repos${NC}"
echo -e "  Repositories with issues: ${YELLOW}$repos_with_issues${NC}"

# Exit with appropriate code
if [[ $repos_with_issues -gt 0 ]]; then
    exit 1
else
    exit 0
fi
